// 🚀 Aviator Game Backend (FULLY SYNCED PLAYER DATA VERSION)

const express = require('express');
const cors = require('cors');
const http = require('http');
const WebSocket = require('ws');
require('dotenv').config();

const app = express();
const server = http.createServer(app);

app.use(cors({
  origin: ['http://localhost:3000', 'http://localhost:5173'],
  credentials: true
}));

app.use(express.json());

// =============================================================================
// GAME STATE
// =============================================================================
let gameState = {
  state: 'betting',     // 'betting' | 'running' | 'crashed'
  multiplier: 1.00,
  countdown: 5,
  crashPoint: 0,
  startTime: 0,
  players: new Map(),      // Map<playerId, { ws, balance }>
  activeBets: new Map(),   // Map<playerId, { amount, cashedOut, cashedOutMultiplier }>
  crashHistory: [2.45, 1.89, 5.67, 1.23, 8.91, 3.45, 2.17, 12.34]  // Array of recent crash multipliers (last 10)
};

function generateCrashPoint() {
  const e = 100, h = Math.random();
  return Math.max(1.01, 1 / (1 - Math.floor(e * Math.pow(Math.E, -h)) / e));
}

// =============================================================================
// GAME LOOP
// =============================================================================
function startGameLoop() {
  console.log('🎮 Game loop started');
  function startBetting() {
    gameState.state = 'betting';
    gameState.multiplier = 1.0;
    gameState.countdown = 5;
    gameState.crashPoint = generateCrashPoint();
    gameState.activeBets.clear();
    console.log(`💰 Betting phase. Crash at ${gameState.crashPoint.toFixed(2)}x`);
    broadcastAll();
    const countdownInterval = setInterval(() => {
      gameState.countdown--;
      broadcastAll();
      if (gameState.countdown <= 0) {
        clearInterval(countdownInterval);
        startFlying();
      }
    }, 1000);
  }
  function startFlying() {
    gameState.state = 'running';
    gameState.startTime = Date.now();
    console.log("✈️ Plane taking off");
    broadcastAll();
    const interval = setInterval(() => {
      const elapsed = Date.now() - gameState.startTime;
      gameState.multiplier = 1.0 + (elapsed / 3000);
      if (gameState.multiplier >= gameState.crashPoint) {
        clearInterval(interval);
        crash();
      } else {
        broadcastAll();
      }
    }, 50);
  }
  function crash() {
    gameState.state = 'crashed';
    gameState.multiplier = gameState.crashPoint;
    
    // Add to crash history (keep last 10)
    gameState.crashHistory.unshift(gameState.crashPoint);
    if (gameState.crashHistory.length > 10) {
      gameState.crashHistory.pop();
    }
    
    console.log(`💥 Crashed at ${gameState.crashPoint.toFixed(2)}x`);
    broadcastAll();
    setTimeout(startBetting, 3000);
  }
  startBetting();
}

// =============================================================================
// WebSocket handling
// =============================================================================
const wss = new WebSocket.Server({ server });

function broadcastAll() {
  // send each player *their own state* (so we can highlight their bet/cashout)
  for (const [playerId, p] of gameState.players.entries()) {
    if (p.ws.readyState !== WebSocket.OPEN) continue;
    const personalBet = gameState.activeBets.get(playerId);
    p.ws.send(JSON.stringify({
      type: 'gameState',
      data: {
        state: gameState.state,
        multiplier: gameState.multiplier,
        countdown: gameState.countdown,
        playersOnline: gameState.players.size,
        hasActiveBet: !!personalBet,
        activeBetAmount: personalBet?.amount || 0,
        cashedOut: personalBet?.cashedOut || false,
        cashedOutMultiplier: personalBet?.cashedOutMultiplier || 0,
        balance: p.balance,
        crashHistory: gameState.crashHistory
      }
    }));
  }
}

wss.on('connection', (ws) => {
  const playerId = Math.random().toString(36).substring(7);
  gameState.players.set(playerId, { ws, balance: 10000 });
  ws.playerId = playerId;

  console.log(`👤 Player ${playerId} connected`);
  console.log(`📊 Sending initial crash history:`, gameState.crashHistory);
  // immediately send current state
  ws.send(JSON.stringify({
    type: 'connected',
    data: { playerId }
  }));

  ws.on('message', (msg) => {
    try {
      const data = JSON.parse(msg);
      const id = ws.playerId;
      if (!id) return;
      if (data.type === 'bet') handleBet(id, data.amount);
      if (data.type === 'cashOut') handleCashOut(id);
    } catch (err) {
      console.error("Could not parse:", msg);
    }
  });

  ws.on('close', () => {
    gameState.players.delete(playerId);
    gameState.activeBets.delete(playerId);
    console.log(`👋 Player ${playerId} disconnected`);
  });
});

// =============================================================================
// Bet / CashOut logic
// =============================================================================
function handleBet(playerId, amount) {
  const player = gameState.players.get(playerId);
  if (!player || gameState.state !== 'betting' || amount > player.balance) return;
  player.balance -= amount;
  gameState.activeBets.set(playerId, {
    amount,
    cashedOut: false,
    cashedOutMultiplier: 0
  });
  player.ws.send(JSON.stringify({ type: 'betPlaced', data: { amount, balance: player.balance } }));
}

function handleCashOut(playerId) {
  const player = gameState.players.get(playerId);
  const bet = gameState.activeBets.get(playerId);
  if (!player || !bet || bet.cashedOut || gameState.state !== 'running') return;
  const winnings = Math.floor(bet.amount * gameState.multiplier);
  bet.cashedOut = true;
  bet.cashedOutMultiplier = gameState.multiplier;
  player.balance += winnings;
  player.ws.send(JSON.stringify({ type: 'cashedOut', data: { winnings, multiplier: bet.cashedOutMultiplier, balance: player.balance } }));
}

// =============================================================================
// REST API
// =============================================================================
app.get('/api/health', (_,res)=>res.json({ status:'OK', players:gameState.players.size }));
app.get('/api/game-state', (_,res)=>res.json({ state:gameState.state, multiplier:gameState.multiplier, countdown:gameState.countdown, players:gameState.players.size }));

const PORT = process.env.PORT || 3002;
server.listen(PORT,()=>{ console.log(`Server on ${PORT}`);startGameLoop(); });
